---
title: "Simulating spatial-temporal data"
author: "`r Sys.Date()`"
output: 
  html_document:
    self_contained: yes
    number_sections: true
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: true
    font: 12pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

set.seed(1026)

library(mgcv)
library(nlme)
library(tidyverse)
library(plotly)
library(mvtnorm)
library(ggpubr)
library(geoR)
library(MBESS)
```


# Basic framework

The simulation, technically, would be established on a continuous space-time domain, even though the final "observations" would be a discrete realization.

Take a Gaussian process for example:

1. The observation is composed of a true latent process and an error process.

\[\begin{aligned}Y_i(\mathbf{s}, t) &= \eta_i(\mathbf{s}, t) +\epsilon_i(\mathbf{s}, t) \\
\epsilon_i(\mathbf{s}, t) & \sim GP(0, \Gamma_{\epsilon})\end{aligned}\]

- $\Gamma_{\epsilon}$ constant across all observations 
- Usually, realization of $\Gamma_{\epsilon}$ on any discrete grid would be $\sigma_{\epsilon}^2\mathbf{I}$. 

2. The true latent process is composed of a fixed process and a random (subject-specific) process. 

\[\begin{aligned}
\eta_i(\mathbf{s}, t) &= \mu(\mathbf{s}, t)+b_i(\mathbf{s}, t) \\
b_i(\mathbf{s}, t) & \sim GP(0, \Gamma_{b})
\end{aligned}\]

- $\mu(\mathbf{s}, t)$ is the population mean function, shared across subjects
- $b_i(\mathbf{s}, t)$ is the individual-level random effect
- We can introduce correlation between space/time by altering the structure of $\Gamma_{b}$

3. The fixed process can be a linear combination of covariates/basis functions

$$\mu(\mathbf{s}, t) = \sum_{p=1}^PX_p(\mathbf{s}, t)\beta_p$$

- $X(\mathbf{s}, t)$ can be either covariates or basis functions, space/time-fixed or varying.

4. The random process, $b_i(\mathbf{s}, t)$, can also be decomposed into the linear combination of basis functions, just like what we did in the fGFPCA project

\[\begin{aligned}b_i(\mathbf{s}, t) &= \sum_{k=1}^K\phi_k(\mathbf{s}, t)\xi_{ik} \\
\mathbf{\xi}_i& \sim N(0, \Gamma_{\xi})
\end{aligned}\]

If we again assume that random spatial and temporal effects are separable, then: 

\[\begin{aligned}b_i(\mathbf{s}, t) &= \sum_{k=1}^K\sum_{l=1}^L\phi_{k}(\mathbf{s})\psi_l(t)\xi_{ikl}\\
\mathbf{\xi}_{ilk}& \sim N(0, \Gamma_{\xi})
\end{aligned}\]

- $\phi_{k}(\mathbf{s}), k = 1...K$ are spatial basis functions
- $\psi_l(t), l = 1...L$ are tempral basis functions
- $\xi_{ikl}$ are individual scores

Another way I can think of it is directly generating $b_i$ directly from a correlation matrix (e.g. AR1). But it seems to be it would be difficult to control on each domain. Also, the space-time domain is probably greater than 2D, on which a correlation matrix would be hard to envision. 

The ultimated gola is to simulated a pair of correlated measure for each voxel (QSM and MWF), so we can calculate a "correlation" at a specific region (lesion) at a specifc time (scan). However, for now, I'll start with a single outcome. 

Since we usually have only a few scans over time for each patient, I was wondering if we could simply code $\psi(t)$ as a random intercept? Basically treating time as a categorical variable? 

# Measurement grid

For now, let's assume data is collected alone a regular grid. meaning subjects are measured at the same spatial coordinates at the same time. There is no missing data. 

- 21 by 21 spatial grid
- 5 measurement time

```{r}
# create spatial grid
# 2D space, 21 points along each axis, 441 spatial points in total
s1 <- s2 <- seq(-1, 1, by = 0.1)
coords <- expand.grid(s1, s2) 
nS <- nrow(coords)
```


```{r}
# create temporal grid
# five measurement time
t <- seq(0.2, 1, by = 0.2)
nT <- length(t)
```


# Generate data for one subject

## Fixed effect

Here we try to generate the fixed component in the true latent process. For now, I'd like to set up a simple structure with three covariates (P = 3): 1) spatial-varying, 2) temporal varying, 3) fixed. No interaction term is included. The coefficients are time-varying but spatial-fixed.

$$\mu(\mathbf{s}, t) = X_1(\mathbf{s})\beta_1(t)+t\beta_2(t)+X_3\beta_3(t)$$

### Spatial-varing covariate

For the spatial-varying covariate $X_1(\mathbf{s})$, let's first try Gaussian process with Matern correlation. Also, since we set the standard deviation at each spatial point as one, the correlation and covariance matrix would have identical values. 

```{r}
# assign an index for each spatial point
coords$pid <- 1:nS
colnames(coords) <- c("s1", "s2", "pid")

# calculate pairwise spatial Euclidiean distance matrix
df_dist <- dist(coords %>% select(s1, s2), diag = T)
df_dist <- as.matrix(df_dist)

# calculate Matern correlation matrix
sp_cormat <- matern(df_dist, phi = 0.25, kappa = 0.25)

# visualize correlation
plot(as.vector(df_dist), as.vector(sp_cormat), 
     type = "p", main = "Matern correlation",
     xlab = "Distance", ylab = "", pch=20, cex = 0.5)
```

```{r}
# Convert correlation matrix to covariance
# in fact, because here I set standard deviation at each location as 1
# the correlation and covariance matrix are identical
sp_covmat <- cor2cov(sp_cormat, sd = rep(1, nS))
# sp_covmat[331:337, 331:337]
# sp_cormat[331:337, 331:337]
```


```{r}
# generate spatial varying covariates from Gaussian process
X1 <- rmvnorm(1, mean = rep(0, nS), sigma = sp_covmat)

df_sp_i <- data.frame(coords, X1=X1[1, ])
# visualization 

plot_ly(data = df_sp_i, x=~s1, y=~s2, z=~X1) %>% add_markers(size = 0.5)

df_sp_i %>% ggplot()+
  geom_tile(aes(x=s1, y=s2, fill=X1))+
  labs(title = "Spatial-varying fixed covariate")
```

### Time-varying coefficient

As we've talked about before, the coefficients $\mathbf{\beta}$ are set as time-varying but not spatial-varying.

Think about a situation where effect goes away as time passes by, meaning the coefficients are decreasing wrt time.

$\beta_p = \frac{\alpha}{t}$

Let's assume spatial- and time-varying covariates contribute equally to the fixed process, while the fixed covariate has the weakest effect 

```{r}
alpha <- c(0.2, -0.2, 0.1)
df_t_i <- data.frame(t=t) %>% mutate(beta1 = alpha[1]/t,
                            beta2 = alpha[2]/t,
                            beta3 = alpha[3]/t)

```


### Overall fixed process

```{r}
df_i <- expand.grid(s1=s1, s2=s2, t=t) %>% 
  left_join(df_sp_i, by = c("s1", "s2")) %>%
  left_join(df_t_i, by = "t") %>%
  mutate(X3 = 1) %>%
  mutate(mu = X1*beta1+t*beta2+X3*beta3)
```


```{r}
df_i %>% 
  ggplot()+
  geom_tile(aes(x=s1, y=s2, fill=mu))+
  facet_wrap(~t)+
  labs(title = "Fixed process")
```


## Random process

Now, let's generate individual-specific random process. The simplest case would be a random slope for each the spatial-varying covariate and time. Also, the scores/random coefficients do not vary with time, and are generate independently from normal distribution.

$b_i(\mathbf{s}, t) =X_1(\mathbf{s})\xi_{i1}+t\xi_{i2}, \ \xi_{ik} \sim N(0, \sigma^2_{k})$


```{r}
# generate random score
xi <- rmvnorm(1, mean = rep(0, 2), sigma = diag(1, 2,2))
df_i <- df_i %>% mutate(bi = X1*xi[1]+t*xi[2])


# visualize
df_i %>% 
  ggplot()+
  geom_tile(aes(x=s1, y=s2, fill=bi))+
  facet_wrap(~t)+
  labs(title = "Random process")
```


# Final outcome

```{r}
df_i$error <- rnorm(nrow(df_i), 1, 0.5)
df_i <- df_i %>% mutate(Y = mu+bi+error)

# visualize
df_i %>% 
  ggplot()+
  geom_tile(aes(x=s1, y=s2, fill=Y))+
  facet_wrap(~t)+
  labs(title = "Outcome")
```